using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using System.Threading;
using Saasi.Shared.Workload;
using Newtonsoft.Json.Serialization;

namespace Saasi.Monolithic.BusinessWeb.Controllers
{
    [Route("api")]
    public class ValuesController : Controller
    {
        // GET api/Business
        [HttpGet("Business")]
        /*
         * io: whether to generate Disk I/O load. (yes if io=1, no if io=0)
         * cpu: whether to generate CPU usage. (yes if cpu=1, no if cpu=0)
         * memory: whether to generate Memory usage. (yes if memory=1, no if memory=0)
         * timestart: the Unix timestamp when the request is sent (generated by the user)
         * timetorun: for how long (in seconds) should we generate the CPU/Memory/IO load?
         * timeout: the maximum time (in seconds) allowed for the request to finish.
         */
        public async Task<JsonResult> SimulateBusinessTransaction(int io,
                                                              int cpu,
                                                              int memory,
                                                              long timestart,
                                                              int timetorun,
                                                              int timeout)
        {
            Guid TranscationID = Guid.NewGuid();


            long StartTimestampMs = timestart * 1000;
            long ExpectedFinishTimeMs = (timestart + timeout) * 1000;
            DateTime StartTimeDateTime = new DateTime(StartTimestampMs); //don't know if it's need to add the 1970
            long ReceivedTimeMs = new DateTime().Ticks; //don't know if it's reasonable
            Console.WriteLine($"Transcation {TranscationID}: Started at {DateTime.Now.ToString()}");

            var tasks = new List<Task<ExecutionResult>>();
            
            if (io == 1)
            {
                var ioWorkload = new IoWorkload();
                tasks.Add(ioWorkload.Run(timetorun));
            }
            if (cpu == 1)
            {
                var cpuWorkload = new CpuWorkload();
                tasks.Add(cpuWorkload.Run(timetorun));
            }
            if (memory == 1)
            {
                var memoryWorkload = new MemoryWorkload();
                tasks.Add(memoryWorkload.Run(timetorun));
            }
            if (tasks.Count > 0) {
                await Task.WhenAll(tasks.ToArray());
            }
            
            var resultList = new Dictionary<string, ExecutionResult>();
            var i = 0;
            if (io == 1) {
                resultList.Add("io", tasks[i].Result);
                ++i;
            }
            if (cpu == 1) {
                resultList.Add("cpu", tasks[i].Result);
                ++i;
            }
            if (memory == 1) {
                resultList.Add("memory", tasks[i].Result);
                ++i;
            }

            Console.WriteLine($"Transcation {TranscationID}: Finished at {DateTime.Now.ToString()}");
            return new JsonResult(new {
                Tasks = resultList.ToArray(),
                Started = StartTimeDateTime.ToString(),
                Finished = DateTime.Now.ToString()
            });
        }

        [HttpGet("status")]
        public string GetStatus() {
            return "OK";
        } 

    }
}
